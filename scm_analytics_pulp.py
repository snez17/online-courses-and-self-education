# -*- coding: utf-8 -*-
"""SCM_Analytics_PuLP

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eezqRFaGzma6O8-hZKQHruqSTUYVCSKW
"""

pip install pulp

from pulp import *

"""**Maximize Bakery Profits**

1 вариант решения
"""

#Initialize Class
model1 = LpProblem(name="Maximize_Bakery_Profits", sense=LpMaximize)

#Define Decision Variables
A = LpVariable('A', lowBound=0, cat='Integer')   #cakes
B = LpVariable('B', lowBound=0, cat='Integer')   #puncakes

#Define Objective Function
model1 += 20*A + 40*B   #profit for cakes and puncakes, prices per unit: 20 and 40

#Define Constraints
model1 += 0.5*A + 1*B <=30   #oven works only 30 days; 0.5 day per unit A and 1 day per unit B
model1 += 1*A + 2.5*B <=60   #two bakers work only 30 days; 1 day per unit A and 2.5 day per unit B
model1 += 1*A + 2*B <=22     #one packers work only 22 days; 1 day per unit A and 2 day per unit B

#Solve model
model1.solve()
print('Produce {} Cake A'.format(A.varValue))
print('Produce {} Cake B'.format(B.varValue))

"""2 вариант решения - создаем словарь с decision variables"""

pip install pulp

from pulp import *

#Initialize Class
model = LpProblem(name="Maximize_Bakery_Profits", sense=LpMaximize)

#Define decision variable
A = LpVariable('A', lowBound=0, cat='Integer')
B = LpVariable('B', lowBound=0, cat='Integer')

var_dict={'A':A,'B':B}

profit_by_cake={
    'A':20,
    'B':40
    }

cake_types = ['A','B']

#Define Objective Function
model += lpSum([profit_by_cake[i]*var_dict[i] for i in cake_types])

#Define Constraints
model += 0.5*A + 1*B <=30   #oven works only 30 days
model += 1*A + 2.5*B <=60   #two bakers work only 30 days
model += 1*A + 2*B <=22     #one packers work only 22 days

#Solve model
model.solve()
print('Produce {} Cake A'.format(A.varValue))
print('Produce {} Cake B'.format(B.varValue))

"""3 вариант решения - создаем датасет с constraints"""

#Initialize Class
model = LpProblem(name="Maximize_Bakery_Profits", sense=LpMaximize)

#Define decision variable
A = LpVariable('A', lowBound=0, cat='Integer')
B = LpVariable('B', lowBound=0, cat='Integer')

#Define Objective Function
model += 20*A + 40*B   #profit for cakes and puncakes, prices per unit: 20 and 40

cake_types = ['A','B']

import pandas as pd

var_dict={'A':A,'B':B}
var_dict

oven = {'A':0.5,'B':1}
baker = {'A':1,'B':2.5}
packer= {'A':1,'B':2}

# Define Constraint
model += (lpSum([oven[i] * var_dict[i] for i in cake_types]) <= 30)
model += (lpSum([baker[i] * var_dict[i] for i in cake_types]) <= 60)
model += (lpSum([packer[i] * var_dict[i] for i in cake_types]) <= 22)

# Solve Model
model.solve()
for i in cake_types: print("{} status {}".format(i, var_dict[i].varValue))

"""4 вариант решения - импортируем csv файл с constraints"""

#Initialize Class
model = LpProblem(name="Maximize_Bakery_Profits", sense=LpMaximize)

cake_types = ['A','B']

#Define decision variable
A = LpVariable('A', lowBound=0, cat='Integer')
B = LpVariable('B', lowBound=0, cat='Integer')

var_dict={'A':A,'B':B}

profit_by_cake={
    'A':20,
    'B':40
    }

#Define Objective Function
model += lpSum([profit_by_cake[i]*var_dict[i] for i in cake_types])

import pandas as pd

from google.colab import drive
drive.mount('/content/gdrive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/gdrive/My Drive/LP plant data

df=pd.read_csv('LP example.csv',delimiter=';',index_col=0)
df

costs = ['oven','baker','packer']

x = LpVariable.dicts("costs", [(i, c) for i in cake_types for c in costs], lowBound=0, cat='Continious')
x

limits = {'oven':30, 'baker':60, 'packer':22}

#Define Constraints
model += 0.5*A + 1*B <=30   #oven works only 30 days; 0.5 day per unit A and 1 day per unit B
model += 1*A + 2.5*B <=60   #two bakers work only 30 days; 1 day per unit A and 2.5 day per unit B
model += 1*A + 2*B <=22     #one packers work only 22 days; 1 day per unit A and 2 day per unit B

#Solve model
model.solve()
print('Produce {} Cake A'.format(A.varValue))
print('Produce {} Cake B'.format(B.varValue))

"""**Loading Truck Problem**"""

prod = ['A','B','C','D','E','F']
weight = {'A':12800, 'B':10900,'C':11400,'D':2100,'E':11300,'F':2300}
prof = {'A':77878,'B':82713,'C':82728,'D':68423,'E':84119,'F':77765}

# Initialize Class
model = LpProblem("Loading Truck Problem", LpMaximize)
# Define Decision Variables
x = LpVariable.dicts('ship_', prod, cat='Binary')

x

# Define Objective
model += lpSum([prof[i]*x[i] for i in prod])
# Define Constraint
model += lpSum([weight[i]*x[i] for i in prod]) <= 20000
#model += x['E'] + x['D'] <= 1   will be alternative combination
#model += x['D'] <= x['B']  or another constraint for combination

# Solve Model
model.solve()
for i in prod: print("{} status {}".format(i, x[i].varValue))

"""**Logistics planning problem**"""

months = ['Jan','Feb','Mar','Apr','May','Jun']
warehouse =  ['New York','Atlanta']
customers = ['East','Midwest','West','South']

costs = {('Atlanta', 'East'): 232,
 ('Atlanta', 'Midwest'): 230,
 ('Atlanta', 'South'): 212,
 ('Atlanta', 'West'): 280,
 ('New York', 'East'): 211,
 ('New York', 'Midwest'): 240,
 ('New York', 'South'): 232,
 ('New York', 'West'): 300}

# Define decision variables
key = [(m, w, c) for m in months for w in warehouse for c in customers]
#key

var_dict = LpVariable.dicts('num_of_shipments', key, lowBound=0, cat='Integer')
#var_dict

# Use the LpVariable dictionary variable to define objective
model += lpSum([costs[(w, c)] * var_dict[(m, w, c)] for m in months for w in warehouse for c in customers])

"""**Traveling salesman problem (TSP)**"""

#Initialize Class
model = LpProblem(name="TSP", sense=LpMinimize)

n = 15 #cities
cities = range(0, 15)
#dist = dataframe

list0 = [0, 29, 82, 46,  68, 52,  72,  42,  51,  55,  29,  74,  23,  72,  46]
list1 = [29,  0,  55,  46,  42, 43,  43,  23,  23,  31,  41,  51,  11,  52,  21]
list2 = [82, 55,  0, 68,  46, 55,  23,  43,  41,  29,  79,  21,  64,  31,  51]
list3 = [46, 46,  68,  0, 82, 15, 72, 31, 62, 42, 21, 51,  51,  43,  64]
list4 = [68, 42,  46,  82, 0, 74,  23,  52,  21,  46,  82,  58,  46,  65,  23]
list5 = [52, 43,  55,  15,  74,  0,  61,  23,  55,  31,  33,  37,  51,  29,  59]
list6 = [72, 43,  23, 72,  23, 61,  0,  42,  23,  31,  77,  37,  51,  46,  33]
list7 = [42, 23,  43,  31,  52, 23,  42,  0,  33,  15,  37,  33,  33,  31,  37]
list8 =  [51, 23,  41,  62,  21, 55,  23,  33,   0,  29, 62,  46,  29, 51,  11]
list9 =  [55, 31,  29,  42,  46, 31,  31,  15,  29,   0,  51,  21,  41,  23,  37]
list10 =  [29, 41,  79,  21,  82, 33,  77,  37,  62,  51,   0,  65,  42,  59,  61]
list11 = [74, 51,  21, 51,  58, 37,  37,  33,  46,  21,  65,  0,  61,  11,  55]
list12 = [23, 11, 64,  51,  46, 51,  51,  33,  29,  41,  42,  61,   0, 62, 23]
list13 = [72, 52,  31,  43,  65, 29,  46,  31,  51,  23,  59,  11,  62,   0,  59]
list14 = [46, 21, 51,  64,  23, 59,  33,  37, 11,  37,  61,  55,  23,  59 ,  0]

list_of_lists = list(zip(list0, list1,list2,list3, list4,list5,list6,list7,list8,list9, list10,list11,
                         list12, list13,list14))
list_of_lists

import pandas as pd

dist = pd.DataFrame(list_of_lists)

# Define Decision Variables
x = LpVariable.dicts('X', [(c1, c2) for c1 in cities for c2 in cities], cat='Binary')
#x
u = LpVariable.dicts('U', [c1 for c1 in cities],
                     lowBound=0, upBound=(n-1), cat='Integer')
#u

# Define Objective
model +=lpSum([dist.iloc[c1, c2] * x[(c1, c2)]
                for c1 in cities for c2 in cities])

# Define Constraints
for c2 in cities: model += lpSum([x[(c1, c2)] for c1 in cities]) == 1
for c1 in cities: model += lpSum([x[(c1, c2)] for c2 in cities]) == 1

# Solve Model
model.solve()
for c1 in cities:
  for c2 in cities:
    print("{} status {}".format((c1,c2),x[(c1,c2)].varValue))

"""**Minimize Transportation Costs**"""

# Initialize Model
model = LpProblem("Minimize Transportation Costs", LpMinimize)

# Build the lists and the demand dictionary
warehouse = ['New York', 'Atlanta']
customers = ['East', 'South', 'Midwest', 'West']
regional_demand = [1800, 1200, 1100, 1000]
demand = dict(zip(customers, regional_demand))

list2_0 = [211,	232]
list2_1 = [232, 212]
list2_2 = [240, 230]
list2_3 = [300, 280]

costs = pd.DataFrame({customers[0]: list2_0, customers[1]:list2_1, customers[2]:list2_2,customers[3]:list2_3})
costs.index = warehouse
costs

x = LpVariable.dicts("wh", [(w,c) for w in warehouse for c in customers], lowBound=0, cat='Integer')

#define decision variable
for w in warehouse:
   for c in customers:
    model += lpSum(costs.loc[w, c] * x[(w, c)])

for c in customers:
  model += lpSum([x[(w, c)]for w in warehouse]) == demand[c]

# Solve Model
model.solve()

print("Status:", LpStatus[model.status])

with open("output.txt", "a") as f:
  for v in model.variables():
    print(v.name, "=", v.varValue, file=f)

f

"""**Scheduling problem - csv**

"""

pip install pulp

import pandas as pd
from pulp import *

from google.colab import drive
drive.mount('/content/gdrive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/gdrive/My Drive/LP plant data

factories =pd.read_csv('factory_variables.csv',delimiter=';',index_col=['MONTH', 'FACTORY'])
factories

demand = pd.read_csv('monthly_demand.csv', delimiter=';', index_col=['MONTH'])
demand

production = LpVariable.dicts("production", ((month, factory) for month, factory in factories.index),
                                     lowBound=0,
                                     cat='Integer')

factory_status = pulp.LpVariable.dicts("factory_status",
                                     ((month, factory) for month, factory in factories.index),
                                     cat='Binary')

model = LpProblem("Cost minimising scheduling problem", LpMinimize)

model += lpSum(
    [production[month, factory] * factories.loc[(month, factory), 'VARIABLE_COSTS'] for month, factory in factories.index]
    + [factory_status[month, factory] * factories.loc[(month, factory), 'FIXED_COSTS'] for month, factory in factories.index]
)

# Production in any month must be equal to demand
months = demand.index
for month in months:
    model += production[(month, 'A')] + production[(month, 'B')] == demand.loc[month, 'DEMAND']

# Production in any month must be between minimum and maximum capacity, or zero.
for month, factory in factories.index:
    min_production = factories.loc[(month, factory), 'MIN_CAPACITY']
    max_production = factories.loc[(month, factory), 'MAX_CAPACITY']
    model += production[(month, factory)] >= min_production * factory_status[month, factory]
    model += production[(month, factory)] <= max_production * factory_status[month, factory]

# Factory B is off in May
model += factory_status[5, 'B'] == 0
model += production[5, 'B'] == 0

model.solve()
LpStatus[model.status]

output = []
for month, factory in production:
    var_output = {
        'MONTH': month,
        'FACTORY': factory,
        'PRODUCTION': production[(month, factory)].varValue,
        'FACTORY STATUS': factory_status[(month, factory)].varValue
    }
    output.append(var_output)
output_df = pd.DataFrame.from_records(output).sort_values(['MONTH', 'FACTORY'])
output_df.set_index(['MONTH', 'FACTORY'], inplace=True)
output_df

# Print our objective function value (Total Costs)
print (value(model.objective))

"""**SOURCE**

https://benalexkeen.com/linear-programming-with-python-and-pulp-part-5/
"""